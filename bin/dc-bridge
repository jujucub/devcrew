#!/bin/bash
#
# dc-bridge - DevCrew 管制システム
# エージェントの状態監視と指示送信を担う
#

set -e

# 共通ライブラリ読み込み
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
source "$SCRIPT_DIR/lib/common.sh"
source "$SCRIPT_DIR/lib/bridge/monitor.sh"
source "$SCRIPT_DIR/lib/bridge/commander.sh"

# Bridge用ディレクトリ
BRIDGE_DIR="$DEVCREW_HOME/bridge"
STATE_FILE="$BRIDGE_DIR/state.json"
COMMANDS_FILE="$BRIDGE_DIR/commands.json"
PID_FILE="$BRIDGE_DIR/bridge.pid"

# デフォルト設定
POLL_INTERVAL=1
DAEMON_MODE=false

# ============================================================
# ヘルプ
# ============================================================
show_help() {
  cat << EOF
Usage: dc-bridge [COMMAND] [OPTIONS]

DevCrew 管制システム - エージェントの状態監視と指示送信

Commands:
  start                    Bridgeを起動（フォアグラウンド）
  stop                     Bridgeを停止
  status                   Bridge と各エージェントの状態を表示
  send <target> <message>  エージェントに指示を送信
  approve <id|--all>       承認待ちを承認
  reject <id> [--message]  承認待ちを拒否

Options:
  -d, --daemon      バックグラウンドで起動
  -h, --help        このヘルプを表示

Examples:
  dc-bridge start                    # フォアグラウンドで起動
  dc-bridge start --daemon           # バックグラウンドで起動
  dc-bridge status                   # 状態確認
  dc-bridge send coder "実装してください"
  dc-bridge approve appr-coder-123   # 特定の承認待ちを承認
  dc-bridge approve --all            # 全ての承認待ちを承認
  dc-bridge reject appr-coder-123    # 拒否
  dc-bridge reject appr-coder-123 --message "別の方法で"
  dc-bridge stop                     # 停止
EOF
}

# ============================================================
# 初期化
# ============================================================
init_bridge() {
  # Bridgeディレクトリ作成
  if [ ! -d "$BRIDGE_DIR" ]; then
    mkdir -p "$BRIDGE_DIR"
    Info "Created bridge directory: $BRIDGE_DIR"
  fi

  # commands.json 初期化（存在しない場合）
  if [ ! -f "$COMMANDS_FILE" ]; then
    echo '{"version":"1.0","pending":[],"processed":[]}' > "$COMMANDS_FILE"
  fi
}

# ============================================================
# Bridge起動
# ============================================================
start_bridge() {
  RequireSession
  init_bridge

  # 既存プロセスチェック
  if [ -f "$PID_FILE" ]; then
    local old_pid=$(cat "$PID_FILE")
    if kill -0 "$old_pid" 2>/dev/null; then
      Warn "Bridge is already running (PID: $old_pid)"
      exit 1
    else
      rm -f "$PID_FILE"
    fi
  fi

  if [ "$DAEMON_MODE" = true ]; then
    # デーモンモード
    Info "Starting Bridge in daemon mode..."
    nohup "$0" _run > "$BRIDGE_DIR/bridge.log" 2>&1 &
    echo $! > "$PID_FILE"
    Success "Bridge started (PID: $!)"
    Info "Log: $BRIDGE_DIR/bridge.log"
  else
    # フォアグラウンドモード
    echo $$ > "$PID_FILE"
    run_bridge
  fi
}

# ============================================================
# Bridgeメインループ
# ============================================================
run_bridge() {
  Info "Bridge started"
  Info "Press Ctrl+C to stop"
  echo ""

  # シグナルハンドラ
  trap cleanup_bridge SIGINT SIGTERM

  while true; do
    # 状態更新
    update_state

    # コマンド処理
    process_commands

    sleep "$POLL_INTERVAL"
  done
}

# ============================================================
# クリーンアップ
# ============================================================
cleanup_bridge() {
  echo ""
  Info "Stopping Bridge..."
  rm -f "$PID_FILE"
  Success "Bridge stopped"
  exit 0
}

# ============================================================
# Bridge停止
# ============================================================
stop_bridge() {
  if [ ! -f "$PID_FILE" ]; then
    Warn "Bridge is not running"
    exit 0
  fi

  local pid=$(cat "$PID_FILE")
  if kill -0 "$pid" 2>/dev/null; then
    kill "$pid"
    rm -f "$PID_FILE"
    Success "Bridge stopped (PID: $pid)"
  else
    Warn "Bridge process not found (stale PID file)"
    rm -f "$PID_FILE"
  fi
}

# ============================================================
# ステータス表示
# ============================================================
show_status() {
  echo -e "${BLUE}═══════════════════════════════════════════════════════${NC}"
  echo -e "${BLUE}  DevCrew Bridge Status${NC}"
  echo -e "${BLUE}═══════════════════════════════════════════════════════${NC}"
  echo ""

  # Bridge状態
  if [ -f "$PID_FILE" ]; then
    local pid=$(cat "$PID_FILE")
    if kill -0 "$pid" 2>/dev/null; then
      echo -e "  Bridge: ${GREEN}Running${NC} (PID: $pid)"
    else
      echo -e "  Bridge: ${RED}Stopped${NC} (stale PID)"
    fi
  else
    echo -e "  Bridge: ${YELLOW}Not running${NC}"
  fi
  echo ""

  # state.json が存在すれば表示
  if [ -f "$STATE_FILE" ]; then
    echo -e "${CYAN}[Agent Status]${NC}"

    # jqがあれば整形表示、なければそのまま
    if command -v jq &> /dev/null; then
      jq -r '.agents | to_entries[] | "  \(.key): \(.value.status) - \(.value.preview // "N/A")"' "$STATE_FILE" 2>/dev/null || cat "$STATE_FILE"
    else
      cat "$STATE_FILE"
    fi
    echo ""

    # 承認待ちがあれば表示
    local pending_count=$(jq -r '.pendingApprovals | length' "$STATE_FILE" 2>/dev/null || echo "0")
    if [ "$pending_count" -gt 0 ]; then
      echo -e "${YELLOW}[Pending Approvals: $pending_count]${NC}"
      jq -r '.pendingApprovals[] | "  [\(.id)] \(.agent): \(.description)"' "$STATE_FILE" 2>/dev/null
      echo ""
    fi
  else
    Warn "state.json not found. Start Bridge first."
  fi

  echo -e "${BLUE}═══════════════════════════════════════════════════════${NC}"
}

# ============================================================
# 指示送信
# ============================================================
send_command() {
  local target=$1
  shift
  local message="$*"

  if [ -z "$target" ] || [ -z "$message" ]; then
    Error "Usage: dc-bridge send <target> <message>"
    exit 1
  fi

  init_bridge

  # コマンドをcommands.jsonに追加
  add_command "message" "$target" "$message"
  Success "Command queued for $target"
}

# ============================================================
# 承認
# ============================================================
approve_command() {
  local approval_id=$1

  if [ -z "$approval_id" ]; then
    Error "Usage: dc-bridge approve <id|--all>"
    exit 1
  fi

  RequireSession

  # state.jsonの確認
  if [ ! -f "$STATE_FILE" ]; then
    Error "state.json not found. Start Bridge first."
    exit 1
  fi

  # jqの確認
  if ! command -v jq &> /dev/null; then
    Error "jq is required for approval commands"
    exit 1
  fi

  if [ "$approval_id" = "--all" ] || [ "$approval_id" = "-a" ]; then
    # 全承認
    approve_all
  else
    # 個別承認
    approve_single "$approval_id"
  fi
}

# 個別承認
approve_single() {
  local approval_id=$1

  # 承認待ちを検索
  local approval=$(jq -r ".pendingApprovals[] | select(.id == \"$approval_id\")" "$STATE_FILE" 2>/dev/null)

  if [ -z "$approval" ] || [ "$approval" = "null" ]; then
    Error "Approval not found: $approval_id"
    echo ""
    echo "Available approvals:"
    jq -r '.pendingApprovals[] | "  \(.id) - \(.agent)"' "$STATE_FILE" 2>/dev/null || echo "  (none)"
    exit 1
  fi

  local pane=$(echo "$approval" | jq -r '.pane')
  local agent=$(echo "$approval" | jq -r '.agent')

  # Yを送信
  tmux send-keys -t "$SESSION:0.$pane" "y" Enter
  Success "Approved: $agent (pane $pane)"
}

# 全承認
approve_all() {
  local pending_count=$(jq -r '.pendingApprovals | length' "$STATE_FILE" 2>/dev/null || echo "0")

  if [ "$pending_count" -eq 0 ]; then
    Info "No pending approvals"
    return 0
  fi

  local approved=0
  while read -r approval; do
    local pane=$(echo "$approval" | jq -r '.pane')
    local agent=$(echo "$approval" | jq -r '.agent')
    local id=$(echo "$approval" | jq -r '.id')

    tmux send-keys -t "$SESSION:0.$pane" "y" Enter
    Success "Approved: $agent ($id)"
    ((approved++))
  done < <(jq -c '.pendingApprovals[]' "$STATE_FILE" 2>/dev/null)

  echo ""
  Info "Approved $approved item(s)"
}

# ============================================================
# 拒否
# ============================================================
reject_command() {
  local approval_id=$1
  shift
  local custom_message=""

  # オプションパース
  while [[ $# -gt 0 ]]; do
    case $1 in
      -m|--message)
        custom_message="$2"
        shift 2
        ;;
      *)
        shift
        ;;
    esac
  done

  if [ -z "$approval_id" ]; then
    Error "Usage: dc-bridge reject <id> [--message <msg>]"
    exit 1
  fi

  RequireSession

  # state.jsonの確認
  if [ ! -f "$STATE_FILE" ]; then
    Error "state.json not found. Start Bridge first."
    exit 1
  fi

  # jqの確認
  if ! command -v jq &> /dev/null; then
    Error "jq is required for rejection commands"
    exit 1
  fi

  # 承認待ちを検索
  local approval=$(jq -r ".pendingApprovals[] | select(.id == \"$approval_id\")" "$STATE_FILE" 2>/dev/null)

  if [ -z "$approval" ] || [ "$approval" = "null" ]; then
    Error "Approval not found: $approval_id"
    echo ""
    echo "Available approvals:"
    jq -r '.pendingApprovals[] | "  \(.id) - \(.agent)"' "$STATE_FILE" 2>/dev/null || echo "  (none)"
    exit 1
  fi

  local pane=$(echo "$approval" | jq -r '.pane')
  local agent=$(echo "$approval" | jq -r '.agent')

  if [ -n "$custom_message" ]; then
    # カスタムメッセージ付き拒否（指示を追加して拒否）
    # まずNを送信
    tmux send-keys -t "$SESSION:0.$pane" "n" Enter
    sleep 0.3
    # カスタムメッセージを送信
    local tmpfile=$(mktemp)
    echo -n "$custom_message" > "$tmpfile"
    tmux load-buffer -b bridge_reject "$tmpfile"
    rm -f "$tmpfile"
    tmux paste-buffer -b bridge_reject -t "$SESSION:0.$pane"
    sleep 0.2
    tmux send-keys -t "$SESSION:0.$pane" Enter
    tmux delete-buffer -b bridge_reject 2>/dev/null || true
    Success "Rejected with message: $agent (pane $pane)"
  else
    # シンプルな拒否
    tmux send-keys -t "$SESSION:0.$pane" "n" Enter
    Info "Rejected: $agent (pane $pane)"
  fi
}

# ============================================================
# メイン
# ============================================================

COMMAND="${1:-}"
shift 2>/dev/null || true

case "$COMMAND" in
  "start")
    while [[ $# -gt 0 ]]; do
      case $1 in
        -d|--daemon)
          DAEMON_MODE=true
          shift
          ;;
        *)
          shift
          ;;
      esac
    done
    start_bridge
    ;;
  "_run")
    # 内部用：デーモンから呼ばれる
    run_bridge
    ;;
  "stop")
    stop_bridge
    ;;
  "status")
    show_status
    ;;
  "send")
    send_command "$@"
    ;;
  "approve")
    approve_command "$@"
    ;;
  "reject")
    reject_command "$@"
    ;;
  "-h"|"--help"|"help"|"")
    show_help
    ;;
  *)
    Error "Unknown command: $COMMAND"
    show_help
    exit 1
    ;;
esac
